#!/usr/bin/env bash
set -o errexit  # abort when any commands exits with error
set -o pipefail # abort when any command in a pipe exits with error
set -o nounset  # abort when any unset variable is used
set -o noglob # prevent bash from expanding glob
set -o errtrace # inherits trap on ERR in function and subshell
trap 'echo status:$? line:$LINENO line:$BASH_LINENO command:"$BASH_COMMAND" functions:$(printf " %s" ${FUNCNAME[@]:-})' ERR
if [[ "${trace:=0}" -eq 1 ]];then
  PS4='${LINENO}: '
  set -x
  export trace
fi

date_alias() {
  if which gdate >/dev/null ; then
    gdate "$@"
  else
    date "$@"
  fi
}
export -f date_alias

while getopts "a:h?" options; do case $options in
  a) a="$OPTARG" ;;
  h|?) help; exit ;;
esac; done; shift $((OPTIND - 1))

: ${working_time_file:="${HOME}/.time_tracking_from_logfiles"}

if [[ "$#" -eq 0 ]];then
  :
  ${0} help

elif [[ "$1" == "help" ]];then shift
  cat ${0} \
    | grep -A5 '^elif' \
    | grep -E '(^elif|shift$)' \
    | sed -e 's/^elif *\[\{1,\} *"\$1" *=\{1,\} *"\([^"]*\)" *\]\{1,\} *; *then *shift *\(#\{0,\}\) *\(.*\)$/\1 \2 \3/g' \
    | sed -e 's/^\( *\)\([^;]*\); *shift$/\1\2/g' \
    || true


elif [[ "$1" == "raw_off" ]];then shift
  raw_log_data="$( find /private/var/log -maxdepth 1 -type f -name "system.log.[0-9]*.gz" \
    | parallel -r 'gzip -dc {}' \
    | tr '\0' '\n' \
    ; cat /private/var/log/system.log \
  )"
  echo "$raw_log_data"

elif [[ "$1" == "off" ]];then shift
  # : ${system_log_filter:="device_generate_lock_screen_screenshot"}
  # : ${system_log_filter:="handle_will_sleep_auth_and_shield_windows"}
  # Oct  5 16:35:58 nasoym com.apple.xpc.launchd[1] (com.apple.xpc.launchd.domain.user.501): Service "com.apple.xpc.launchd.unmanaged.loginwindow.96" tried to hijack endpoint "com.apple.tsm.uiserver" from owner: com.apple.SystemUIServer.agent
  : ${system_log_filter:="com.apple.xpc.launchd.unmanaged.loginwindow"}
  
  raw_log_data="$( $0 raw_off | grep "${system_log_filter}" )"
  raw_timestamps="$( awk '{print $1,$2,$3}' <<<"${raw_log_data}" \
    | parallel 'date_alias -d "$(echo {})" "+%F %T"' \
    | sort
  )"
  raw_json_data="$(jq -R 'split(" ")' <<<"${raw_timestamps}" \
    | jq -s 'map({date:.[0],time:.[1]})|group_by(.date)|map({date:(.[0].date),time:(.|sort_by(.time))})'
  )"
  # jq -c 'map(.time=(.time[-1].time)|.type="stop")[]' <<<"${raw_json_data}"
  # jq -c '.' <<<"${raw_json_data}"
  # jq 'map(.type="stop")[]' <<<"${raw_json_data}"
  jq -c 'map(.time|=(map(.type="stop")))[]' <<<"${raw_json_data}"

elif [[ "$1" == "raw_on" ]];then shift
  raw_log_data="$( find /var/log -maxdepth 1 -type f -name "system.log.[0-9]*.gz" 2>/dev/null \
    | sort \
    | parallel -r 'gzip -dc {}' \
    | tr '\0' '\n' \
    ;  cat /var/log/system.log \
  )"
  echo "$raw_log_data"

elif [[ "$1" == "on" ]];then shift

# 2018-09-24 08:25:30.806813+0200  localhost loginwindow[102]: (Security) [com.apple.securityd:KCLogin] StorageManager::login: loginDLDbIdentifier is /Users/.../Library/Keychains/login.keychain
# 2018-09-24 08:25:30.807437+0200  localhost loginwindow[102]: (Security) [com.apple.securityd:KCLogin] Attempting to unlock login keychain "/Users/.../Library/Keychains/login.keychain-db"
# 2018-09-24 08:26:04.814138+0200  localhost authd[122]: [com.apple.Authorization:authd] UID 501 authenticated as user ... (UID 501) for right 'com.apple.trust-settings.user'
# 2018-09-24 08:26:04.814152+0200  localhost authd[122]: [com.apple.Authorization:authd] engine: - validating credential ... (501) for authenticate-session-owner
# 2018-09-24 08:26:04.814154+0200  localhost authd[122]: [com.apple.Authorization:authd] engine: - credential 501 is session owner (does satisfy rule)
# 2018-09-24 08:26:04.814170+0200  localhost authd[122]: [com.apple.Authorization:authd] Succeeded authorizing right 'com.apple.trust-settings.user' by client '/usr/sbin/ocspd' [66774] for authorization created by '/Applications/Mail.app' [3763] (3,0)
# 2018-09-24 08:26:04.814616+0200  localhost ocspd[66774]: (libsystem_info.dylib) Created Activity ID: 0x1a1cfd, Description: Membership API: translate identifier
# 2018-09-24 08:25:19.609625+0200  localhost loginwindow[102]: (BezelServices) [com.apple.BezelServices:loginwindow] notification: User Is ACTIVE.  Unsuppressing keyboard brightness

# 2018-09-26 08:32:19.892786+0200  localhost loginwindow[102]: (Sharing) [com.apple.sharing:AutoUnlock] Dynamic store enabled state {
# 2018-09-26 08:32:19.893225+0200  localhost loginwindow[102]: (LocalAuthentication) [com.apple.LocalAuthentication:LAContext] -[LAContext initWithExternalizedContext:] 0 on <private>
# 2018-09-26 08:32:19.893580+0200  localhost loginwindow[102]: (LocalAuthentication) [com.apple.LocalAuthentication:LAClient] -[LAClient evaluatePolicy:options:uiDelegate:reply:] 1, {
# 2018-09-26 08:32:19.895560+0200  localhost loginwindow[102]: (LocalAuthentication) [com.apple.LocalAuthentication:LAClient] -[LAClient evaluatePolicy:options:uiDelegate:reply:]_block_invoke -> (null), Error Domain=com.apple.LocalAuthentication Code=-6 "Biometry is not available on this device." UserInfo={BiometryType=0, NSLocalizedDescription=Biometry is not available on this device.} on <private>
# 2018-09-26 08:32:19.895602+0200  localhost loginwindow[102]: (LocalAuthentication) [com.apple.LocalAuthentication:LAContext] -[LAContext dealloc]  on <private>

  
  # : ${system_log_filter:="login"}
  # raw_log_data="$( $0 raw_on | grep -w "${system_log_filter}" )"
  # raw_timestamps="$( awk '{print $1,$2,$3}' <<<"${raw_log_data}" \
  #   | parallel 'date_alias -d "$(echo {})" "+%F %T"' \
  #   | sort
  # )"
  # raw_json_data="$(jq -R 'split(" ")' <<<"${raw_timestamps}" \
  #   | jq -s 'map({date:.[0],time:.[1]})|group_by(.date)|map({date:(.[0].date),time:(.|sort_by(.time))})'
  # )"
  # # jq -c 'map(.time=(.time[0].time)|.type="start")[]' <<<"${raw_json_data}"
  # jq -c 'map(.time|=(map(.type="start")))[]' <<<"${raw_json_data}"


  log show \
    --predicate 'subsystem == "com.apple.sharing" && category == "AutoUnlock" && eventMessage contains "Dynamic store enabled state"' \
    --last 6d \
    --style json \
  | jq -c 'map({date:(.timestamp|gsub(" .*";"")),time:(.timestamp|gsub("[0-9-]* ";"")|gsub("\\..*";"")),type:"start"})|group_by(.date)|map({date:(.[0].date),time:(.)})[]' \
  | jq -c -s '.|sort_by(.date)|.[1:]|.[]'

elif [[ "$1" == "show_joined" ]];then shift
  : ${default_stop_time:="16:10:00"}
  ( $0 on ; $0 off ) | jq -s -c "\
group_by(.date)\
|map({\
  date:.[0].date,\
  events:(.|map(.time)|flatten|map(del(.date))|sort_by(.time))\
})\
|map(.start=(.events|map(select(.type==\"start\"))|first|.time))\
|map(.stop=(.events|map(select(.type==\"stop\"))|last|.time//\"${default_stop_time}\"))\
|map(del(.events))\
|map(if(.stop==null) then del(.stop) else . end)\
|map(if(.start==null) then del(.start) else . end)\
|sort_by(.date)\
|.[]\
    "

elif [[ "$1" == "calc_duration" ]];then shift
  jq -s -c "\
map(\
  .duration=(\
    (\
      ((.m_stop//.stop)|split(\":\")[0]|tonumber)\
      + ((.m_stop//.stop)|split(\":\")[1]|tonumber/60)\
    )\
    - \
    (\
      ((.m_start//.start)|split(\":\")[0]|tonumber)\
      + ((.m_start//.start)|split(\":\")[1]|tonumber/60)\
    )\
    - \
    (\
      ((.break//\"00:00\")|split(\":\")[0]|tonumber)\
      + ((.break//\"00:00\")|split(\":\")[1]|tonumber/60)\
    )\
  )\
  |.duration=(.duration*10|floor|./10)
)\
|.[]\
    "
elif [[ "$1" == "add_total" ]];then shift
  jq -s -c " . += [{total:(.|map(.duration)|add//0|.*100|floor|./100)}] |.[] "

elif [[ "$1" == "dates_of_this_week" ]];then shift
  : ${week:="- 0"}
  : ${day:="$(date_alias -d "${week} week" +%F)"}

  seq 0 4 \
    | parallel "date_alias -d \"${day} - \$(( \$(date_alias +%u) - 1)) days + {} days\" +%F" \
    | sort \
    | jq -R '.' \
    | jq -c -s '.'

elif [[ "$1" == "add_week" ]];then shift
  : ${week:="+ 1"}
  new_entries_with_date_keys="$( 
    $0 dates_of_this_week \
      | jq -c 'map({date:.,start:"09:00:00",stop:"16:10:00",break:"00:10"})[]' \
      | jq -s '.' \
      | jq 'map({"\(.date)":.})|add'
    )"
  cat ${working_time_file} \
    | jq -s '.' \
    | jq 'map({"\(.date)":.})|add' \
    | jq -c --argjson new_entries "${new_entries_with_date_keys}" \
      '$new_entries + . |flatten |sort_by(.date)|.[]' \
    | sponge ${working_time_file}

elif [[ "$1" == "entries_of_this_week" ]];then shift
  cat ${working_time_file} \
    | jq \
      -s -c \
      --argjson this_week "$($0 dates_of_this_week)" \
      'map(select([.date]|inside($this_week)))[]'

elif [[ "$1" == "this_week" ]];then shift
  $0 entries_of_this_week \
    | $0 calc_duration \
    | $0 add_total

elif [[ "$1" == "duration_from_logs" ]];then shift
  $0 show_joined \
    | $0 calc_duration

elif [[ "$1" == "update" ]];then shift
  new_entries_with_date_keys="$( $0 show_joined \
      | jq -s '.' \
      | jq 'map({"\(.date)":.})|add'
    )"
  cat ${working_time_file} \
    | jq -s '.' \
    | jq 'map({"\(.date)":.})|add' \
    | jq -c --argjson new_entries "${new_entries_with_date_keys}" \
      '. * $new_entries |flatten |sort_by(.date)|.[]' \
    | sponge ${working_time_file}

elif [[ "$1" == "last_weeks" ]];then shift
  : ${weeks:="${1:-"-1,-0"}"}
  read -r -a array <<<"$(echo -n "$weeks" | tr ',' ' ')"

  for i in "${array[@]}"; do
    cat <(week="$i" $0 this_week)
  done  \
    | jq \
      -s \
      -c \
      --arg count "${#array[@]}" \
      '.+=[{average:(.|map(select(has("total") and (.total!=0))|.total)|length as $entry_count|add|./=($entry_count)|.*=100|floor|./=100)}]|.[]'

elif [[ "$1" == "week_average" ]];then shift
  # readarray -t array <<<"$(printf "$1" | tr ',' '\n')"
  # declare -p array
  : ${weeks:="${1:-"-1,-0"}"}
  read -r -a array <<<"$(echo -n "$weeks" | tr ',' ' ')"

  for i in "${array[@]}"; do
    cat <(week="$i" $0 this_week)
  done  \
    | jq \
      -s \
      --arg count "${#array[@]}" \
      'map(select(has("total"))|.total)|{totals:(.),average:(add|./=($count|tonumber)|.*=100|floor|./=100)}'

elif [[ "$1" == "edit" ]];then shift
  vim ${working_time_file}

fi

