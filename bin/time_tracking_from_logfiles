#!/usr/bin/env bash
set -o errexit  # abort when any commands exits with error
set -o pipefail # abort when any command in a pipe exits with error
set -o nounset  # abort when any unset variable is used
set -o noglob # prevent bash from expanding glob
set -o errtrace # inherits trap on ERR in function and subshell
trap 'echo status:$? line:$LINENO line:$BASH_LINENO command:"$BASH_COMMAND" functions:$(printf " %s" ${FUNCNAME[@]:-})' ERR
if [[ "${trace:=0}" -eq 1 ]];then
  PS4='${LINENO}: '
  set -x
  export trace
fi

while getopts "a:h?" options; do case $options in
  a) a="$OPTARG" ;;
  h|?) help; exit ;;
esac; done; shift $((OPTIND - 1))

: ${working_time_file:="${HOME}/.time_tracking_from_logfiles"}
: ${time_event_file:="${HOME}/.time_tracking_events"}

if [[ "$#" -eq 0 ]];then
  :
  ${0} help

elif [[ "$1" == "help" ]];then shift
  cat ${0} \
    | grep -A5 '^elif' \
    | grep -E '(^elif|shift$)' \
    | sed -e 's/^elif *\[\{1,\} *"\$1" *=\{1,\} *"\([^"]*\)" *\]\{1,\} *; *then *shift *\(#\{0,\}\) *\(.*\)$/\1 \2 \3/g' \
    | sed -e 's/^\( *\)\([^;]*\); *shift$/\1\2/g' \
    || true

elif [[ "$1" == "raw_off_events" ]];then shift
  (
    find /private/var/log -maxdepth 1 -type f -name "system.log.[0-9]*.gz" |
      parallel -r 'gzip -dc {}' |
      tr '\0' '\n' ;
      cat /private/var/log/system.log 
  ) | 
  grep "com.apple.xpc.launchd.unmanaged.loginwindow" |
  awk '{print $1,$2,$3}' |
  jq -cRS ' split(" ")| { month:.[0], day:.[1], time:.[2] } '  |
  jq -sc \
    --arg year "$(date +%Y)" \
    '
    map(
      {
        date:("\($year) \(.month) \(.day)"|strptime("%Y %b %d")|mktime|strftime("%F")),
        time,
        type:"stop"
      }
    ) |
    map(
      .date_time=(.date+"T"+.time)|
      .epoche=(.date+"T"+.time|strptime("%FT%T")|mktime|strftime("%s")|tonumber)
    )[]
    '

elif [[ "$1" == "raw_on_events" ]];then shift
  : ${on_days:="6d"}
  log show \
    --predicate 'subsystem == "com.apple.sharing" && category == "AutoUnlock" && eventMessage contains "Dynamic store enabled state"' \
    --last ${on_days} \
    --style json |
  jq -c '
    map(
      {
        date:(.timestamp|gsub(" .*$";"")),
        time:(.timestamp|gsub("^.* ";"")|gsub("\\.[0-9]*.*$";"")),
        epoche:(.timestamp|gsub("\\.[0-9]*.*$";"")|strptime("%F %T")|mktime|strftime("%s")|tonumber),
        type:"start"
      }
    ) |
    map(
      .date_time=(.date+"T"+.time)
    )[]
  '

elif [[ "$1" == "get_all_duration_events" ]];then shift
  (
    ${0} raw_off_events ;
    ${0} raw_on_events
  ) |
  ${0} extract_duration_from_start_stop_events

elif [[ "$1" == "extract_duration_from_start_stop_events" ]];then shift
  jq -sc 'sort_by(.date_time)|reverse|.[]' |
  sed -n '/stop/{N;s/\n/,/g;/start/p}' |
  sed -e 's/^/[/' -e 's/$/]/' |
  jq -cs '
  map({
    hour:(map(select(.type=="start")|.time|gsub(":[0-9]*:[0-9]*$";"")|tonumber)|first),
    date:(map(select(.type=="start")|.date)|first),
    start:(map(select(.type=="start")|.time)|first),
    stop:(map(select(.type=="stop")|.time)|first),
    start_epoche:(map(select(.type=="start")|.epoche)|first),
    stop_epoche:(map(select(.type=="stop")|.epoche)|first)
  })|
  map({
    date,
    time:(.date+"T"+.start),
    start,
    stop,
    type:(if (.hour>18) then "private" else "work" end ),
    duration_hours:((.stop_epoche - .start_epoche)/60/60|.*=10|floor|./=10),
    duration_minutes:((.stop_epoche - .start_epoche)/60|floor),
  })' |
  jq -c 'sort_by(.time)|.[]'

elif [[ "$1" == "last_duration_event" ]];then shift
  (
    export on_days=1d;
    ${0} raw_on_events | sed -n '$p' ; 
    jq -cn \
      --arg date "$(date +%F)" \
      --arg time "$(date +%T)" \
      '{
        date:$date,
        time:$time,
        date_time:($date+"T"+$time),
        epoche:($date +"T" + $time|strptime("%FT%T")|mktime|strftime("%s")|tonumber),
        type:"stop"
      }'
  ) |
  ${0} extract_duration_from_start_stop_events 

elif [[ "$1" == "show_raw_events" ]];then shift
  cat ${time_event_file}

elif [[ "$1" == "edit_events" ]];then shift
  vim ${time_event_file}

elif [[ "$1" == "update_events" ]];then shift
  ${0} show_raw_events |
  jq -sc 'map(.time=(.date+"T"+.start))[]' |
  jq -sc \
    --argjson new_entries "$(${0} get_all_duration_events | jq -sc . )" \
    '
      . + $new_entries | 
      unique_by(.time) |
      flatten |
      sort_by(.time) |
      map(del(.time)) |
      .[]
    ' |
  sponge ${time_event_file}

elif [[ "$1" == "show_events" ]];then shift
  ( 
    ${0} show_raw_events ;
    ${0} last_duration_event 
  ) |
  ${0} calc_duration_per_day

elif [[ "$1" == "calc_duration_per_day" ]];then shift
  jq -sc '
    group_by(.date)|
    map({
      date:(first|.date),
      work:(
        map(
          select(.type=="work")|
          if (.duration_hours!=null) then .duration_hours
          elif (.duration_minutes!=null) then .duration_minutes / 60
          else 0 end
        )|
        add//0|.*=10|floor|./=10
      ),
      private:(
        map(
          select(.type=="private")|
          if (.duration_hours!=null) then .duration_hours
          elif (.duration_minutes!=null) then .duration_minutes / 60
          else 0 end
        )|
        add//0|.*=10|floor|./=10
      )
    })|
    sort_by(.date)|
    .[]
    '


# elif [[ "$1" == "show_joined" ]];then shift
#   : ${default_stop_time:="16:10:00"}
#   ( $0 on ; $0 off ) | jq -s -c "\
# group_by(.date)\
# |map({\
#   date:.[0].date,\
#   events:(.|map(.time)|flatten|map(del(.date))|sort_by(.time))\
# })\
# |map(.start=(.events|map(select(.type==\"start\"))|first|.time))\
# |map(.stop=(.events|map(select(.type==\"stop\"))|last|.time//\"${default_stop_time}\"))\
# |map(del(.events))\
# |map(if(.stop==null) then del(.stop) else . end)\
# |map(if(.start==null) then del(.start) else . end)\
# |sort_by(.date)\
# |.[]\
#     "
#
# elif [[ "$1" == "calc_duration" ]];then shift
#   jq -s -c '
#     map(
#       .duration=(
#         ( ((.m_stop//.stop)|split(":")[0]|tonumber) + ((.m_stop//.stop)|split(":")[1]|tonumber/60) )
#         - 
#         ( ((.m_start//.start)|split(":")[0]|tonumber) + ((.m_start//.start)|split(":")[1]|tonumber/60) )
#         - 
#         ( ((.break//"00:00")|split(":")[0]|tonumber) + ((.break//"00:00")|split(":")[1]|tonumber/60) )
#         + 
#         ( ((.additional//"00:00")|split(":")[0]|tonumber) + ((.additional//"00:00")|split(":")[1]|tonumber/60) )
#       )
#       |.duration=(.duration*10|floor|./10)
#       | if (.duration < 2 ) then .duration=7 else .duration=.duration end
#     )
#     |.[]
#     '
#
# elif [[ "$1" == "add_total" ]];then shift
#   jq -s -c " . += [{total:(.|map(.duration)|add//0|.*100|floor|./100)}] |.[] "
#
# elif [[ "$1" == "dates_of_this_week" ]];then shift
#   : ${week:="- 0"}
#   : ${day:="$(date_alias -d "${week} week" +%F)"}
#
#   seq 0 4 \
#     | parallel "date_alias -d \"${day} - \$(( \$(date_alias +%u) - 1)) days + {} days\" +%F" \
#     | sort \
#     | jq -R '.' \
#     | jq -c -s '.'
#
# elif [[ "$1" == "add_week" ]];then shift
#   : ${week:="+ 1"}
#   new_entries_with_date_keys="$( 
#     $0 dates_of_this_week \
#       | jq -c 'map({date:.,start:"09:00:00",stop:"16:10:00",break:"00:10"})[]' \
#       | jq -s '.' \
#       | jq 'map({"\(.date)":.})|add'
#     )"
#   cat ${working_time_file} \
#     | jq -s '.' \
#     | jq 'map({"\(.date)":.})|add' \
#     | jq -c --argjson new_entries "${new_entries_with_date_keys}" \
#       '$new_entries + . |flatten |sort_by(.date)|.[]' \
#     | sponge ${working_time_file}
#
# elif [[ "$1" == "entries_of_this_week" ]];then shift
#   cat ${working_time_file} \
#     | jq \
#       -s -c \
#       --argjson this_week "$($0 dates_of_this_week)" \
#       'map(select([.date]|inside($this_week)))[]'
#
# elif [[ "$1" == "this_week" ]];then shift
#   $0 entries_of_this_week \
#     | $0 calc_duration \
#     | $0 add_total
#
# elif [[ "$1" == "duration_from_logs" ]];then shift
#   $0 show_joined \
#     | $0 calc_duration
#
# elif [[ "$1" == "update" ]];then shift
#   new_entries_with_date_keys="$( $0 show_joined \
#       | jq -s '.' \
#       | jq 'map({"\(.date)":.})|add'
#     )"
#   cat ${working_time_file} \
#     | jq -s '.' \
#     | jq 'map({"\(.date)":.})|add' \
#     | jq -c --argjson new_entries "${new_entries_with_date_keys}" \
#       '. * $new_entries |flatten |sort_by(.date)|.[]' \
#     | sponge ${working_time_file}
#
# elif [[ "$1" == "last_weeks" ]];then shift
#   : ${weeks:="${1:-"-1,-0"}"}
#   read -r -a array <<<"$(echo -n "$weeks" | tr ',' ' ')"
#
#   for i in "${array[@]}"; do
#     cat <(week="$i" $0 this_week)
#   done  \
#     | jq \
#       -s \
#       -c \
#       --arg count "${#array[@]}" \
#       '.+=[
#           {average:(
#             .|
#             map(select(has("total") and (.total!=0))|.total) |
#             length as $entry_count|
#             add|
#             ./=($entry_count)|
#             .*=100|
#             floor|
#             ./=100)
#           },
#           {overtime:(
#             map(select(has("total") and (.total!=0))|.total) |
#             length as $entry_count|
#             add - ($entry_count * 35 )|
#             .*=100|
#             floor|
#             ./=100
#             )}
#           ]|
#         .[]'
#
# elif [[ "$1" == "week_average" ]];then shift
#   # readarray -t array <<<"$(printf "$1" | tr ',' '\n')"
#   # declare -p array
#   : ${weeks:="${1:-"-1,-0"}"}
#   read -r -a array <<<"$(echo -n "$weeks" | tr ',' ' ')"
#
#   for i in "${array[@]}"; do
#     cat <(week="$i" $0 this_week)
#   done  \
#     | jq \
#       -s \
#       --arg count "${#array[@]}" \
#       'map(select(has("total"))|.total)|{totals:(.),average:(add|./=($count|tonumber)|.*=100|floor|./=100)}'
#
# elif [[ "$1" == "edit" ]];then shift
#   vim ${working_time_file}
#
fi

