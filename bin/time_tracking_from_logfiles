#!/usr/bin/env bash
set -o errexit  # abort when any commands exits with error
set -o pipefail # abort when any command in a pipe exits with error
set -o nounset  # abort when any unset variable is used
set -o noglob # prevent bash from expanding glob
set -o errtrace # inherits trap on ERR in function and subshell
trap 'echo status:$? line:$LINENO line:$BASH_LINENO command:"$BASH_COMMAND" functions:$(printf " %s" ${FUNCNAME[@]:-})' ERR
if [[ "${trace:=0}" -eq 1 ]];then
  PS4='${LINENO}: '
  set -x
  export trace
fi

while getopts "a:h?" options; do case $options in
  a) a="$OPTARG" ;;
  h|?) help; exit ;;
esac; done; shift $((OPTIND - 1))

: ${working_time_file:="${HOME}/.time_tracking_from_logfiles"}
: ${time_event_file:="${HOME}/.time_tracking_events"}

if [[ "$#" -eq 0 ]];then
  :
  ${0} help

elif [[ "$1" == "help" ]];then shift
  bash_scripts show_commands "${0}"

elif [[ "$1" == "raw_off_events" ]];then shift
  : ${file_pattern:="[0-9]"}
  (
    find /private/var/log -maxdepth 1 -type f -name "system.log.${file_pattern}*.gz" |
      parallel -r 'gzip -dc {}' |
      tr '\0' '\n' ;
      cat /private/var/log/system.log 
  ) | 
  grep "com.apple.xpc.launchd.unmanaged.loginwindow" |
  awk '{print $1,$2,$3}' |
  jq -cRS ' split(" ")| { month:.[0], day:.[1], time:.[2] } '  |
  jq -sc \
    --arg year "$(date +%Y)" \
    '
    map(
      {
        date:("\($year) \(.month) \(.day)"|strptime("%Y %b %d")|mktime|strftime("%F")),
        time,
        type:"stop"
      }
    ) |
    map(
      .epoche=(.date+"T"+.time|strptime("%FT%T")|mktime|strftime("%s")|tonumber)
    )[]
    '

elif [[ "$1" == "now_as_stop_event" ]];then shift
    jq -cn \
      --arg date "$(date +%F)" \
      --arg time "$(date +%T)" \
      '{
        date:$date,
        time:$time,
        type:"stop",
        epoche:($date +"T" + $time|strptime("%FT%T")|mktime|strftime("%s")|tonumber)
      }'

elif [[ "$1" == "raw_on_events" ]];then shift
  : ${on_days:="6d"}
  log show \
    --predicate 'subsystem == "com.apple.sharing" && category == "AutoUnlock" && eventMessage contains "Dynamic store enabled state"' \
    --last ${on_days} \
    --style json |
  jq -c '
    map(
      {
        date:(.timestamp|gsub(" .*$";"")),
        time:(.timestamp|gsub("^.* ";"")|gsub("\\.[0-9]*.*$";"")),
        type:"start",
        epoche:(.timestamp|gsub("\\.[0-9]*.*$";"")|strptime("%F %T")|mktime|strftime("%s")|tonumber)
      }
    )[]
  '

elif [[ "$1" == "extract_duration_from_start_stop_events" ]];then shift
  jq -sc 'sort_by("\(.date)\(.time)")|reverse|.[]' |
  sed -n '/stop/{N;s/\n/,/g;/start/p}' |
  sed -e 's/^/[/' -e 's/$/]/' |
  jq -cs '
  map({
    hour:(map(select(.type=="start")|.time|gsub(":[0-9]*:[0-9]*$";"")|tonumber)|first),
    day:(map(select(.type=="start")|.date|strptime("%F")|mktime|strftime("%a"))|first),
    date:(map(select(.type=="start")|.date)|first),
    start:(map(select(.type=="start")|.time)|first),
    stop:(map(select(.type=="stop")|.time)|first),
    start_epoche:(map(select(.type=="start")|.epoche)|first),
    stop_epoche:(map(select(.type=="stop")|.epoche)|first)
  })|
  map({
    date,
    start,
    stop,
    type:(
      if ((.day=="Sun") or (.day=="Sat") ) then "private" 
      elif (.hour>18) then "private" 
      else "work" end 
      ),
    duration_hours:((.stop_epoche - .start_epoche)/60/60|.*=100|floor|./=100),
    duration_minutes:((.stop_epoche - .start_epoche)/60|floor),
  })|
  sort_by("\(.date)\(.start)")[]
  '

elif [[ "$1" == "get_all_duration_events" ]];then shift
  (
    ${0} raw_off_events ;
    ${0} raw_on_events
  ) |
  ${0} extract_duration_from_start_stop_events

elif [[ "$1" == "get_last_24h_duration_events" ]];then shift
  (
    on_days=1d ${0} raw_on_events;
    file_pattern="[0-1]" ${0} raw_off_events;
    ${0} now_as_stop_event;
  ) |
  ${0} extract_duration_from_start_stop_events 

elif [[ "$1" == "show_raw_events" ]];then shift
  cat ${time_event_file}

elif [[ "$1" == "calc_duration_per_day" ]];then shift
  jq -sc '
    group_by(.date)|
    map({
      date:(first|.date),
      day:(first|.date|strptime("%F")|mktime|strftime("%a")),
      work:(
        map(
          select(.type=="work")|
          if (.duration_hours!=null) then .duration_hours
          elif (.duration_minutes!=null) then .duration_minutes / 60
          else 0 end
        )|
        add//0|.*=100|floor|./=100
      ),
      private:(
        map(
          select(.type=="private")|
          if (.duration_hours!=null) then .duration_hours
          elif (.duration_minutes!=null) then .duration_minutes / 60
          else 0 end
        )|
        add//0|.*=100|floor|./=100
      )
    })|
    sort_by(.date)|
    .[]
    '

elif [[ "$1" == "update" ]];then shift
  ${0} show_raw_events |
  jq -sc \
    --argjson new_entries "$(${0} get_all_duration_events | jq -sc . )" \
    '
      . + $new_entries | 
      unique_by("\(.date)\(.start)") |
      flatten |
      sort_by("\(.date)\(.start)") |
      .[]
    ' |
  sponge ${time_event_file}

elif [[ "$1" == "edit" ]];then shift
  vim ${time_event_file}

elif [[ "$1" == "report" ]];then shift
  ( 
    ${0} show_raw_events ;
    ${0} get_last_24h_duration_events ;
  ) |
  jq -sc '
    unique_by("\(.date)\(.start)\(.duration_hours)") |
    sort_by("\(.date)\(.start)")|
    .[]
  ' |
  ${0} calc_duration_per_day

elif [[ "$1" == "dates_of_week" ]];then shift
  : ${week:="${1:-"-0"}"}
  # : ${week:="-0"}
  : ${day_in_week:="$(date -d "${week} week" +%F)"}
  seq 0 4 |
    parallel "date -d \"${day_in_week} - \$(( \$(date +%u) - 1)) days + {} days\" +%F" |
    jq -R  |
    jq -sc 'sort'

elif [[ "$1" == "week_report" ]];then shift
  : ${weeks:="${1:-"-1,-0"}"}
  read -r -a array <<<"$(echo -n "$weeks" | tr ',' ' ')"
  for i in "${array[@]}"; do
    weekdates="$(time_tracking_from_logfiles dates_of_week $i)"
    ${0} report | 
      jq -sc --argjson weekdates "${weekdates}" \
      'map(select([.date]|inside($weekdates))|.work)|
        add|
        {
          week:($weekdates|first|strptime("%F")|mktime|strftime("%W")),
          total:(.|.*=10|floor|./=10)
        }
      '
  done 


# elif [[ "$1" == "last_weeks" ]];then shift
#   : ${weeks:="${1:-"-1,-0"}"}
#   read -r -a array <<<"$(echo -n "$weeks" | tr ',' ' ')"
#
#   for i in "${array[@]}"; do
#     cat <(week="$i" $0 this_week)
#   done  \
#     | jq \
#       -s \
#       -c \
#       --arg count "${#array[@]}" \
#       '.+=[
#           {average:(
#             .|
#             map(select(has("total") and (.total!=0))|.total) |
#             length as $entry_count|
#             add|
#             ./=($entry_count)|
#             .*=100|
#             floor|
#             ./=100)
#           },
#           {overtime:(
#             map(select(has("total") and (.total!=0))|.total) |
#             length as $entry_count|
#             add - ($entry_count * 35 )|
#             .*=100|
#             floor|
#             ./=100
#             )}
#           ]|
#         .[]'
#
# elif [[ "$1" == "week_average" ]];then shift
#   # readarray -t array <<<"$(printf "$1" | tr ',' '\n')"
#   # declare -p array
#   : ${weeks:="${1:-"-1,-0"}"}
#   read -r -a array <<<"$(echo -n "$weeks" | tr ',' ' ')"
#
#   for i in "${array[@]}"; do
#     cat <(week="$i" $0 this_week)
#   done  \
#     | jq \
#       -s \
#       --arg count "${#array[@]}" \
#       'map(select(has("total"))|.total)|{totals:(.),average:(add|./=($count|tonumber)|.*=100|floor|./=100)}'
#

else
  echo "unknown command: $@" >&2
  exit 1

fi

